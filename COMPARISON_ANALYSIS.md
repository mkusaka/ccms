# tui-realm v3 AttrValue実装方法の比較分析

## 背景
tui-realm v3への移行時に、`AttrValue`の制限により複雑な型（`Vec<SearchResult>`など）を扱う必要がありました。

## 2つのアプローチ

### 1. Bincodeラッパー方式（現在の実装）

**実装概要**:
```rust
// グローバルストアにbincodeでシリアライズしたデータを保存
pub struct TypeSafeStore {
    storage: Arc<Mutex<HashMap<String, Vec<u8>>>>,
    counter: Arc<Mutex<u64>>,
}

// IDを使ってAttrValue::Stringとして渡す
AttrValue::String("__type_safe__id_123")
```

**メリット**:
- ✅ 完全な型安全性（コンパイル時チェック）
- ✅ 任意の複雑な型をそのまま扱える
- ✅ シリアライズが高速（bincode）
- ✅ 既存の型定義を変更する必要がない

**デメリット**:
- ❌ グローバル状態の管理が必要
- ❌ メモリリークの可能性（手動削除が必要）
- ❌ 追加の依存関係（bincode）
- ❌ tui-realm v3の標準機能を使わない

### 2. ネイティブPayload方式（新規検証）

**実装概要**:
```rust
// AttrValue::Payloadを使用
AttrValue::Payload(PropPayload::Map(HashMap<String, PropValue>))
```

**メリット**:
- ✅ フレームワークネイティブな実装
- ✅ グローバル状態が不要
- ✅ メモリ管理が自動
- ✅ 追加の依存関係が不要

**デメリット**:
- ❌ PropValueの制限（24種類のプリミティブ型のみ）
- ❌ 複雑な型は文字列にシリアライズする必要がある
- ❌ Vec<SearchResult>のような配列の扱いが煩雑
- ❌ 型安全性が低下（文字列パースが必要）

## パフォーマンス比較

| 項目 | Bincode方式 | Payload方式 |
|------|------------|------------|
| シリアライズ速度 | 高速 | 中速（文字列変換） |
| メモリ使用量 | 中（グローバルストア） | 低（直接保持） |
| GCプレッシャー | 低 | 低 |
| スレッド競合 | あり（Mutex） | なし |

## 実装の複雑さ

### Bincode方式
- TypeSafeStoreの実装: ~150行
- トレイト実装: ~20行/型
- 使用側: シンプル

### Payload方式
- 変換関数: ~100行/型
- 使用側: やや複雑（手動変換）

## 推奨事項

### 現状維持（Bincode方式）を推奨する理由：

1. **型安全性の重要性**: Rustの最大の利点である型安全性を維持
2. **既存コードの安定性**: 既に実装・テスト済み
3. **将来の拡張性**: 新しい複雑な型も簡単に追加可能
4. **開発効率**: 型変換を意識せずに開発可能

### ただし、以下の改善を推奨：

1. **メモリリーク対策**:
   ```rust
   // 自動削除機能の追加
   impl Drop for TypeSafeWrapper {
       fn drop(&mut self) {
           // IDを自動削除
       }
   }
   ```

2. **パフォーマンス最適化**:
   ```rust
   // DashMapを使用してロック競合を削減
   use dashmap::DashMap;
   ```

## 結論

フィードバックで指摘された`AttrValue::Payload`は確かに存在しますが、現在のbincodeラッパー方式の方が：
- より型安全
- より保守しやすい
- より拡張性が高い

ため、現在の実装を維持することを推奨します。ただし、メモリ管理の改善は実施すべきです。